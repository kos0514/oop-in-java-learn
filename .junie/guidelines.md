# Java OOPプロジェクト - ガイドライン

## プロジェクト概要
このプロジェクトはSpring Bootを使用したコンソールベースの「異世界転生」（Isekai Transmigration）ゲームです。プレイヤーは異世界に転生するキャラクターを作成し、世界と種族を選択して、その選択に基づいてキャラクターのステータスを受け取ることができます。

## プロジェクト構造

```
oop-in-java-learn/
├── src/main/java/com/kos0514/oop_in_java_learn/
│   ├── entity/           # データベースエンティティクラス
│   ├── enums/            # 列挙型
│   ├── factory/          # オブジェクト生成のためのファクトリークラス
│   ├── mapper/           # データベースアクセス用のMyBatisマッパー
│   ├── model/            # ドメインモデルクラス
│   │   └── value/        # 値オブジェクト
│   ├── repository/       # リポジトリインターフェース
│   ├── service/          # サービスクラス
│   │   ├── game/         # ゲームメカニクスサービス
│   │   ├── race/         # 種族選択サービス
│   │   └── world/        # 世界選択サービス
│   └── util/             # ユーティリティクラス
```

## コーディング規約

### 1. オブジェクト指向設計原則
- **カプセル化**: 適切なgetterとsetterを持つプライベートフィールドの使用
- **継承**: 共通機能に継承を使用
- **ポリモーフィズム**: 柔軟な設計のためのインターフェースと抽象クラスの使用
- **抽象化**: 明確に定義されたインターフェースの背後に実装の詳細を隠す

### 2. 値オブジェクト
- ドメインコンセプト（例：`SoulName`、`Age`）には不変の値オブジェクトを使用
- コンストラクタまたはファクトリーメソッドで入力を検証
- 適切なequals/hashCode/toStringメソッドの実装（適宜Lombokを使用）

### 3. デザインパターン
- **ファクトリーパターン**: 複雑なオブジェクトの作成に使用（例：`TransmigratorFactory`、`PlayableStatusesFactory`）
- **ビルダーパターン**: オプションパラメータが多いオブジェクトに使用
- **ストラテジーパターン**: 交換可能なアルゴリズムにストラテジーインターフェースを使用
- **リポジトリパターン**: データアクセス抽象化にリポジトリを使用

### 4. コード構成
- 関連する機能をパッケージにグループ化
- 説明的なクラスとメソッド名を使用
- Javaの命名規則に従う（メソッド/変数にはキャメルケース、クラスにはパスカルケース）

### 5. ドキュメント
- すべての公開クラスとメソッドをJavadocでドキュメント化
- パラメータの説明と戻り値の説明を含める
- スローされる可能性のある例外をドキュメント化

## データベースガイドライン

### 1. MyBatis統合
- データベースアクセスにMyBatisを使用
- マッパーは`mapper`パッケージで定義
- ボイラープレートコードにはMyBatis Generatorを使用

### 2. エンティティクラス
- エンティティクラスは`entity`パッケージに保持
- 生成されたエンティティは`entity.generated`パッケージに配置
- 生成されたコードを直接変更しない

## ゲームメカニクス

### 1. 転生プロセス
1. 基本情報（名前、年齢）の収集
2. 世界の選択
3. じゃんけんで利用可能な種族レア度を決定
4. 種族の選択
5. 年齢、種族、ランダム要素に基づくキャラクターステータスの生成

### 2. 種族レア度システム
- **STANDARD（一般）**: デフォルトで利用可能
- **UNIQUE（レア）**: じゃんけん1回勝利で選択可能
- **LEGENDARY（スーパーレア）**: じゃんけん2回連続勝利で選択可能
- **SECRET（ウルトラレア）**: じゃんけん3回連続勝利で選択可能

## 開発ワークフロー

### 1. 新機能の追加
1. ドメインモデルと値オブジェクトを定義
2. ビジネスロジックを持つサービスクラスを実装
3. 必要に応じてファクトリークラスを作成
4. 必要に応じてデータベーススキーマとマッパーを更新
5. 適切なテストを追加

### 2. テスト
- すべてのビジネスロジックに対してユニットテストを作成
- テストにはJUnitを使用
- 適切な場合は依存関係をモック化

## ベストプラクティス

1. **不変性**: 可能な限り不変オブジェクトを優先
2. **検証**: 入力を早期に検証し、明確なエラーメッセージを提供
3. **関心の分離**: クラスを単一の責任に集中させる
4. **依存性注入**: 依存関係の管理にSpringのDIコンテナを使用
5. **例外処理**: 適切な例外タイプを使用し、適切なレベルで例外を処理

## 技術スタック
- Java 21
- Spring Boot 3.4.4
- MyBatis
- MySQL
- Lombok
